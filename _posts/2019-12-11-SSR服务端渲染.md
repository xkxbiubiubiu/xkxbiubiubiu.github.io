---
layout:     post
title:    笔记-SSR服务端渲染
subtitle:  
date:       2019-12-11
author:     
header-img: 
catalog: true
tags:
    - < 笔记整理 >
typora-root-url: ..

---



# vue SSR服务端渲染

## 理论部分

#### 1.为什么使用SSR

-  更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 
-  更快的内容到达时间  

但要权衡

-  开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数中使用
-  涉及构建设置和部署的更多要求 
-  更多的服务器端负载 

## 代码部分

```javascript
//开服务
const express = require('express')
const app = express()

app.get('*',function(req,res){

})
app.listen(8080,function(){
    console.log('server is running at 8080')
})
```

```JavaScript
//用res.end()返回html模板
const express = require('express')
const app = express()
app.get('*',function(req,res){
    res.end(`<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Document</title>
    </head>
    <body>
        <p>HELLO SSR</p>
    </body>
    </html>`)
})
app.listen(8080,function(){
    console.log('server is running at 8080')
})
```

```JavaScript
//使用vue-server-renderer转化vue模板
const express = require('express')
const Vue = require('vue')
const ServerRenderer = require('vue-server-renderer')
const renderer = ServerRenderer.createRenderer()

const app = express()
const vm = new Vue({
    template:`<div>
        <input v-model="val"/>
        <p>{{val}}</p>
    </div>`,
    data:{
        val:'HELLO SSR'
    }
})

app.get('*',function(req,res){
    renderer.renderToString(vm,function(err,html){
        if(err){
            throw err;
        }else{
            res.end(`<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
            </head>
            <body>
                ${html}
            </body>
            </html>`)
        }
    })
   
})
app.listen(8091,function(){
    console.log('server is running at 8091')
})
```

```javascript
//使用template模板
const express = require('express')
const Vue = require('vue')
const ServerRenderer = require('vue-server-renderer')
const fs = require('fs')
const renderer = ServerRenderer.createRenderer({
    template:fs.readFileSync('../index.template.html','utf8')
})


const app = express()
const vm = new Vue({
    template:`<div>
        <input v-model="val"/>
        <p>{{val}}</p>
    </div>`,
    data:{
        val:'HELLO SSR'
    }
})

app.get('*',function(req,res){
    renderer.renderToString(vm,function(err,html){
        if(err){
            throw err;
        }else{
            res.end(html)
        }
    })
   
})
app.listen(8091,function(){
    console.log('server is running at 8091')
})
```

```html
<模板>
<!DOCTYPE html>
<html lang="en">
  <head><title>Hello</title></head>
  <body>
    <!--vue-ssr-outlet-->
  </body>
</html>
```

这样渲染只是把模板渲染成字符串

因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例，使用webpack



